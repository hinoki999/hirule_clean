from dataclasses import dataclass
from typing import Dict, Optional, List, Callable
from decimal import Decimal
import numpy as np
from datetime import datetime, timedelta
from .stress_testing import StressTester
from .advanced_risk import AdvancedRiskManager

@dataclass
class CircuitBreakerConfig:
    ###"""Configuration for circuit breaker thresholds###"""
    max_drawdown: float = 0.15  # 15% max drawdown
    var_multiplier: float = 2.0  # VaR breach threshold
    correlation_threshold: float = 0.8  # High correlation warning
    volatility_threshold: float = 0.5  # Annualized volatility threshold
    position_concentration: float = 0.3  # Max position size as % of portfolio
    minimum_liquidity: float = 0.5  # Minimum liquidity ratio

@dataclass
class CircuitBreakerAlert:
    ###"""Alert generated by circuit breaker checks###"""
    severity: str  # 'WARNING', 'CRITICAL'
    message: str
    timestamp: datetime
    metric: str
    current_value: float
    threshold: float
    recommended_action: str

class CircuitBreaker:
    ###"""Automated risk control system###"""

    def __init__(self,
                 risk_manager: AdvancedRiskManager,
                 stress_tester: StressTester,
                 config: Optional[CircuitBreakerConfig] = None):
        self.risk_manager = risk_manager
        self.stress_tester = stress_tester
        self.config = config or CircuitBreakerConfig()
        self.alerts: List[CircuitBreakerAlert] = []
        self.last_check = datetime.now()

    def check_portfolio_risk(self, positions: Dict[str, Decimal]) -> List[CircuitBreakerAlert]:
        ###"""Run comprehensive risk checks###"""
        self.alerts = []  # Reset alerts
        current_time = datetime.now()

        # Run stress tests
        stress_results = self.stress_tester.run_historical_scenario("extreme_volatility", positions)

        # Check VaR breach
        base_var = stress_results["base_var"]
        stressed_var = stress_results["stressed_var"]
        if stressed_var > base_var * self.config.var_multiplier:
            self.alerts.append(CircuitBreakerAlert(
                severity="CRITICAL",
                message="Stress test shows severe VaR breach",
                timestamp=current_time,
                metric="stressed_var",
                current_value=stressed_var,
                threshold=base_var * self.config.var_multiplier,
                recommended_action="Reduce position sizes or increase hedging"
            ))

        # Check correlation risk
        corr_matrix = self.risk_manager.calculate_correlation_matrix()
        if corr_matrix.shape[0] > 1:
            # Get maximum off-diagonal correlation
            mask = ~np.eye(corr_matrix.shape[0], dtype=bool)
            max_correlation = np.abs(corr_matrix[mask]).max()

            if max_correlation > self.config.correlation_threshold:
                self.alerts.append(CircuitBreakerAlert(
                    severity="WARNING",
                    message="High correlation between positions detected",
                    timestamp=current_time,
                    metric="max_correlation",
                    current_value=float(max_correlation),
                    threshold=self.config.correlation_threshold,
                    recommended_action="Consider diversifying across uncorrelated assets"
                ))

        # Check position concentration
        total_value = sum(float(pos * Decimal(str(self.risk_manager.price_history[sym][-1])))
                         for sym, pos in positions.items())

        for symbol, position in positions.items():
            position_value = float(position * Decimal(str(self.risk_manager.price_history[symbol][-1])))
            concentration = position_value / total_value

            if concentration > self.config.position_concentration:
                self.alerts.append(CircuitBreakerAlert(
                    severity="WARNING",
                    message=f"High concentration in {symbol}",
                    timestamp=current_time,
                    metric="concentration",
                    current_value=concentration,
                    threshold=self.config.position_concentration,
                    recommended_action=f"Consider reducing {symbol} position"
                ))

        # Check drawdown
        results = self.stress_tester.monte_carlo_stress_test(positions)
        if results["max_drawdown"] > self.config.max_drawdown:
            self.alerts.append(CircuitBreakerAlert(
                severity="CRITICAL",
                message="Excessive drawdown risk detected",
                timestamp=current_time,
                metric="max_drawdown",
                current_value=results["max_drawdown"],
                threshold=self.config.max_drawdown,
                recommended_action="Reduce overall exposure or implement stop-losses"
            ))

        self.last_check = current_time
        return self.alerts

    def get_portfolio_recommendations(self, positions: Dict[str, Decimal]) -> Dict[str, float]:
        ###"""Generate position adjustment recommendations###"""
        # Run risk checks first
        alerts = self.check_portfolio_risk(positions)

        # Initialize recommendations
        recommendations = {symbol: 0.0 for symbol in positions}  # 0.0 means no change

        # Process alerts
        for alert in alerts:
            if alert.severity == "CRITICAL":
                # Recommend larger position reductions for critical alerts
                if alert.metric == "stressed_var":
                    # Reduce positions proportionally to bring VaR down
                    reduction_factor = alert.threshold / alert.current_value
                    for symbol in positions:
                        recommendations[symbol] = min(recommendations[symbol], reduction_factor - 1)

            elif alert.severity == "WARNING":
                # More moderate adjustments for warnings
                if alert.metric == "concentration":
                    # Recommend specific position reduction
                    symbol = alert.message.split()[-2]  # Extract symbol from message
                    target_ratio = self.config.position_concentration
                    current_ratio = alert.current_value
                    recommendations[symbol] = target_ratio / current_ratio - 1

        return recommendations

    def should_suspend_trading(self) -> tuple[bool, str]:
        ###"""Determine if trading should be suspended###"""
        critical_alerts = [a for a in self.alerts if a.severity == "CRITICAL"]
        if len(critical_alerts) >= 2:
            return True, "Multiple critical risk breaches detected"

        # Check for severe market conditions
        total_warnings = len(self.alerts)
        if total_warnings >= 4:
            return True, "Multiple risk warnings across different metrics"

        return False, ""
